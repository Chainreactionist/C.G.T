{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"C.G.T is a game template that aims to simplify the game prototyping and development process by providing a standardized development environment. C.G.T provides you with all the basic tools you would need to get started on new project and prevent you from shooting yourself in the foot by spending time on the non-prototyping related parts of the project. Info Contribute to C.G.T. If you make a Service or Controller that you find very helpful and you think it should be included. Make a pull request or contact me or share it in the discord server. Contact Github Info C.G.T is still in beta. A lot of aspects are subject to change. Services currently available PlayerDataService - A module to manage the loading and unloading of player data. PlayerTempDataService - A module to manage the loading and unloading of temporary player data. CommandBarService - A module that allows you to easily create admin commands using the CMDR module by Evaera\u2764\ufe0f. Controllers currently available CommandBarController - Register's keybindings for opening the CommandBar. Services in the works ProductService - A module that allows you to manage all purchases that happen in the game and reports this to both PlayerDataService and GameAnalyticsService . SettingsService - A module to manage players settings and create events for settings changes. Controllers in the works SettingsService Get Started","title":"Home"},{"location":"#services-currently-available","text":"PlayerDataService - A module to manage the loading and unloading of player data. PlayerTempDataService - A module to manage the loading and unloading of temporary player data. CommandBarService - A module that allows you to easily create admin commands using the CMDR module by Evaera\u2764\ufe0f.","title":"Services currently available"},{"location":"#controllers-currently-available","text":"CommandBarController - Register's keybindings for opening the CommandBar.","title":"Controllers currently available"},{"location":"#services-in-the-works","text":"ProductService - A module that allows you to manage all purchases that happen in the game and reports this to both PlayerDataService and GameAnalyticsService . SettingsService - A module to manage players settings and create events for settings changes.","title":"Services in the works"},{"location":"#controllers-in-the-works","text":"SettingsService Get Started","title":"Controllers in the works"},{"location":"getting-started/","text":"Installation Clone the latest release game VS Code Release Go to https://www.roblox.com/games/9108577465/C-G-T . Click on the 3 dots. And click edit. Go to https://github.com/Chainreactionist/C.G.T/releases/latest . Download the .zip file. Unzip the file by double clicking it and open it in visual studio code or your editor of choice. Out of the box all you need to do next is Start Rojo using to VS code rojo plugin and then connect using the roblox studio roblox plugn. Info A plugin is in the works to load different versions of C.G.T in the future","title":"Getting Started"},{"location":"getting-started/#installation","text":"Clone the latest release game VS Code Release Go to https://www.roblox.com/games/9108577465/C-G-T . Click on the 3 dots. And click edit. Go to https://github.com/Chainreactionist/C.G.T/releases/latest . Download the .zip file. Unzip the file by double clicking it and open it in visual studio code or your editor of choice. Out of the box all you need to do next is Start Rojo using to VS code rojo plugin and then connect using the roblox studio roblox plugn. Info A plugin is in the works to load different versions of C.G.T in the future","title":"Installation"},{"location":"template/","text":"Module template It's important to keep code consistent this is what I have found to work really well. Check out the MadLife - code_guidebook & Roblox Style Guide --!strict --[[ {C.G.T} -[ModuleName]--------------------------------------- Module description Members: Functions: Members [ClassName]: Methods [ClassName]: --]] ----- Loaded Modules ----- local SETTINGS = {} ----- Module Table ----- local Module = {} ----- Private Variables ----- ----- Private functions ----- ----- Public ----- ----- Initialize & Connections ----- return Module Basic Usage --!strict --[[ {C.G.T} -[PlayerDataService]--------------------------------------- A module to manage the loading and unloading of player data. Links: IMPORTANT\u2757, It's essential that you understand how these modules work to efficiently use C.G.T and understand how my code works \ud83d\udc4d https://madstudioroblox.github.io/ReplicaService/ https://madstudioroblox.github.io/ProfileService/ https://sleitnick.github.io/Knit/ https://github.com/osyrisrblx/t https://eryn.io/roblox-lua-promise/docs/WhyUsePromises Members [PlayerDataService]: ProfileStore: --> [ProfileStore] (To view a player's date through DataStoreEditor \"PlayerData\" --> \"Player_\"..UserId (Player_1).) GlobalUpdateHandlers: --> [Folder] (To handle a new sort of Update you need to add a module to this folder that returns the handler function.) Profiles: --> [{player_profile}] (Table of player profiles, removed once player leaves the server and can be retrieved using PlayerDataService:GetProfile().) Replicas: --> [{player_profile_Replica}] (Table of player replicas, removed once player leaves the server and can be retrieved using PlayerDataService:GetReplica(). It is used to replicate data to the client.) Methods [PlayerDataService]: GetProfile(player: Player) --> Promise<player_profile> GetData(player: Player) --> Promise<player_profile.Data> (The format of Profile.Data is based on SETTINGS.SaveStructure) GetDataReplica(player: Player) --> Promise<Replica> (Use this object to edit player data) AddGlobalUpdate(UpdateData: { Id: string, SenderId: number, ReceiverId: number, Data: {} }) GlobalUpdates are used to send info to players across servers and regardless of whether or not they are online. --]] ----- Loaded Modules ----- local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local RunService = game : GetService ( \"RunService\" ) local Players = game : GetService ( \"Players\" ) local ProfileService = require ( ReplicatedStorage . Packages . profileservice ) local ReplicaService = require ( ReplicatedStorage . Packages . replicaservice ) local Knit = require ( ReplicatedStorage . Packages . knit ) local Promise = require ( ReplicatedStorage . Packages . promise ) local t = require ( ReplicatedStorage . Packages . t ) local SETTINGS = { MockProfiles = false , ClassToken = ReplicaService . NewClassToken ( \"PlayerData\" ), SaveStructure = { SomeData = 0 , }, } type UpdateData = { Id : string , SenderId : number , TimeSent : number , ReceiverId : number , Data : {} } ----- Module Table ----- local PlayerDataService = Knit . CreateService ({ Name = \"PlayerDataService\" , ProfileStore = ProfileService . GetProfileStore ( \"PlayerData\" , SETTINGS . SaveStructure ), Profiles = {}, ProfileDataReplicas = {}, }) ----- Private Variables ----- local TYPES = { UpdateData = t . strictInterface ({ Id = t . string , SenderId = t . number , ReceiverId = t . number , TimeSent = t . number , Data = t . optional ( t . table ), }), } local GlobalUpdateHandlers = script . GlobalUpdateHandlers local ProfileServiceErrorHandlers = script . ProfileServiceErrorHandlers ----- Private functions ----- local function OnPlayerJoining ( player : Player ) local player_profile if RunService : IsStudio () and SETTINGS . MockProfiles then player_profile = PlayerDataService . ProfileStore . Mock : LoadProfileAsync ( \"Player_\" .. tostring ( player . UserId )) else player_profile = PlayerDataService . ProfileStore : LoadProfileAsync ( \"Player_\" .. tostring ( player . UserId )) end if player_profile ~= nil then player_profile : AddUserId ( player . UserId ) player_profile : Reconcile () player_profile : ListenToRelease ( function () PlayerDataService . Profiles [ player ] = nil local ProfileReplica = PlayerDataService . ProfileDataReplicas [ player ] if ProfileReplica ~= nil then ProfileReplica : Destroy () PlayerDataService . ProfileDataReplicas [ player ] = nil end player : Kick () end ) if player : IsDescendantOf ( Players ) == true then local ProfileReplica = ReplicaService . NewReplica ({ ClassToken = SETTINGS . ClassToken , Tags = { Player = player }, Data = player_profile . Data , Replication = \"All\" , }) PlayerDataService . Profiles [ player ] = player_profile PlayerDataService . ProfileDataReplicas [ player ] = ProfileReplica local function OnActiveGlobalUpdate ( UpdateId : number , UpdateData : UpdateData ) assert ( t . number ( UpdateId ) and TYPES . UpdateData ( UpdateData )) player_profile . GlobalUpdates : LockActiveUpdate ( UpdateId ) end local function OnLockedGlobalUpdate ( UpdateId : number , UpdateData : UpdateData ) assert ( t . number ( UpdateId ) and TYPES . UpdateData ( UpdateData )) local LockedUpdateHandler = GlobalUpdateHandlers : FindFirstChild ( UpdateData . Id ) if LockedUpdateHandler then Promise . try ( require ( LockedUpdateHandler ), UpdateId , UpdateData ) : andThen ( function ( ClearUpdate : boolean ) if ClearUpdate ~= false then player_profile . GlobalUpdates : ClearLockedUpdate ( UpdateId ) end end ) : catch ( warn ) : await () else warn ( \"[PlayerDataService]: GlobalUpdateHandler not found\" ) end end for _ , ActiveUpdate in pairs ( player_profile . GlobalUpdates : GetActiveUpdates ()) do OnActiveGlobalUpdate ( ActiveUpdate [ 1 ], ActiveUpdate [ 2 ]) end for _ , LockedUpdate in pairs ( player_profile . GlobalUpdates : GetLockedUpdates ()) do task . spawn ( OnLockedGlobalUpdate , LockedUpdate [ 1 ], LockedUpdate [ 2 ]) end player_profile . GlobalUpdates : ListenToNewActiveUpdate ( OnActiveGlobalUpdate ) player_profile . GlobalUpdates : ListenToNewLockedUpdate ( OnLockedGlobalUpdate ) else player_profile : Release () end else player : Kick () end end local function OnPlayerLeaving ( player : Player ) local player_profile = PlayerDataService . Profiles [ player ] if player_profile ~= nil then player_profile : Release () end end ----- Public ----- function PlayerDataService : GetProfile ( player : Player | any ) assert ( t . instance ( \"Player\" )( player )) return Promise . new ( function ( resolve , reject ) repeat if not player : IsDescendantOf ( Players ) then reject ( \"Player left the game\" ) end task . wait ( 1 ) until PlayerDataService . Profiles [ player ] ~= nil local player_profile = PlayerDataService . Profiles [ player ] if player_profile ~= nil then if player_profile : IsActive () then resolve ( player_profile ) end else reject ( \"Profile is nil\" ) end reject ( \"Player left the game\" ) end ) end function PlayerDataService : GetData ( player : Player | any ) assert ( t . instance ( \"Player\" )( player )) return Promise . new ( function ( resolve , reject ) repeat if not player : IsDescendantOf ( Players ) then reject ( \"Player left the game\" ) end task . wait ( 1 ) until PlayerDataService . Profiles [ player ] ~= nil local player_profile = PlayerDataService . Profiles [ player ] if player_profile ~= nil then if player_profile : IsActive () then resolve ( player_profile . Data ) end else reject ( \"Profile is nil\" ) end reject ( \"Player left the game\" ) end ) end function PlayerDataService : GetDataReplica ( player : Player | any ) assert ( t . instance ( \"Player\" )( player )) return Promise . new ( function ( resolve , reject ) repeat if not player : IsDescendantOf ( Players ) then reject ( \"Player left the game\" ) end task . wait ( 1 ) until PlayerDataService . ProfileDataReplicas [ player ] ~= nil local player_profile_replica = PlayerDataService . ProfileDataReplicas [ player ] if player_profile_replica ~= nil then if player_profile_replica : IsActive () then resolve ( player_profile_replica ) end else reject ( \"player_profile_replica is nil\" ) end reject ( \"Player left the game\" ) end ) end function PlayerDataService : AddGlobalUpdate ( update_data : UpdateData ) assert ( TYPES . UpdateData ( update_data )) return Promise . new ( function ( resolve , reject ) PlayerDataService . ProfileStore : GlobalUpdateProfileAsync ( \"Player_\" .. tostring ( update_data . ReceiverId ), function ( globalUpdates ) globalUpdates : AddActiveUpdate ( update_data ) end ) resolve () end ) end ----- Initialize & Connections ----- function PlayerDataService : KnitInit () for _ , player in pairs ( Players : GetPlayers ()) do task . spawn ( OnPlayerJoining , player ) end -- Used to connect datastore errors to game analytics endpoints for _ , ErrorHandler : ModuleScript in pairs ( ProfileServiceErrorHandlers : GetChildren ()) do if ErrorHandler : IsA ( \"ModuleScript\" ) then if ProfileService [ ErrorHandler . Name ] then ProfileService [ ErrorHandler . Name ]: Connect ( require ( ErrorHandler )) end end end Players . PlayerAdded : Connect ( OnPlayerJoining ) Players . PlayerRemoving : Connect ( OnPlayerLeaving ) end return PlayerDataService","title":"Code Template"},{"location":"template/#module-template","text":"It's important to keep code consistent this is what I have found to work really well. Check out the MadLife - code_guidebook & Roblox Style Guide --!strict --[[ {C.G.T} -[ModuleName]--------------------------------------- Module description Members: Functions: Members [ClassName]: Methods [ClassName]: --]] ----- Loaded Modules ----- local SETTINGS = {} ----- Module Table ----- local Module = {} ----- Private Variables ----- ----- Private functions ----- ----- Public ----- ----- Initialize & Connections ----- return Module","title":"Module template"},{"location":"template/#basic-usage","text":"--!strict --[[ {C.G.T} -[PlayerDataService]--------------------------------------- A module to manage the loading and unloading of player data. Links: IMPORTANT\u2757, It's essential that you understand how these modules work to efficiently use C.G.T and understand how my code works \ud83d\udc4d https://madstudioroblox.github.io/ReplicaService/ https://madstudioroblox.github.io/ProfileService/ https://sleitnick.github.io/Knit/ https://github.com/osyrisrblx/t https://eryn.io/roblox-lua-promise/docs/WhyUsePromises Members [PlayerDataService]: ProfileStore: --> [ProfileStore] (To view a player's date through DataStoreEditor \"PlayerData\" --> \"Player_\"..UserId (Player_1).) GlobalUpdateHandlers: --> [Folder] (To handle a new sort of Update you need to add a module to this folder that returns the handler function.) Profiles: --> [{player_profile}] (Table of player profiles, removed once player leaves the server and can be retrieved using PlayerDataService:GetProfile().) Replicas: --> [{player_profile_Replica}] (Table of player replicas, removed once player leaves the server and can be retrieved using PlayerDataService:GetReplica(). It is used to replicate data to the client.) Methods [PlayerDataService]: GetProfile(player: Player) --> Promise<player_profile> GetData(player: Player) --> Promise<player_profile.Data> (The format of Profile.Data is based on SETTINGS.SaveStructure) GetDataReplica(player: Player) --> Promise<Replica> (Use this object to edit player data) AddGlobalUpdate(UpdateData: { Id: string, SenderId: number, ReceiverId: number, Data: {} }) GlobalUpdates are used to send info to players across servers and regardless of whether or not they are online. --]] ----- Loaded Modules ----- local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local RunService = game : GetService ( \"RunService\" ) local Players = game : GetService ( \"Players\" ) local ProfileService = require ( ReplicatedStorage . Packages . profileservice ) local ReplicaService = require ( ReplicatedStorage . Packages . replicaservice ) local Knit = require ( ReplicatedStorage . Packages . knit ) local Promise = require ( ReplicatedStorage . Packages . promise ) local t = require ( ReplicatedStorage . Packages . t ) local SETTINGS = { MockProfiles = false , ClassToken = ReplicaService . NewClassToken ( \"PlayerData\" ), SaveStructure = { SomeData = 0 , }, } type UpdateData = { Id : string , SenderId : number , TimeSent : number , ReceiverId : number , Data : {} } ----- Module Table ----- local PlayerDataService = Knit . CreateService ({ Name = \"PlayerDataService\" , ProfileStore = ProfileService . GetProfileStore ( \"PlayerData\" , SETTINGS . SaveStructure ), Profiles = {}, ProfileDataReplicas = {}, }) ----- Private Variables ----- local TYPES = { UpdateData = t . strictInterface ({ Id = t . string , SenderId = t . number , ReceiverId = t . number , TimeSent = t . number , Data = t . optional ( t . table ), }), } local GlobalUpdateHandlers = script . GlobalUpdateHandlers local ProfileServiceErrorHandlers = script . ProfileServiceErrorHandlers ----- Private functions ----- local function OnPlayerJoining ( player : Player ) local player_profile if RunService : IsStudio () and SETTINGS . MockProfiles then player_profile = PlayerDataService . ProfileStore . Mock : LoadProfileAsync ( \"Player_\" .. tostring ( player . UserId )) else player_profile = PlayerDataService . ProfileStore : LoadProfileAsync ( \"Player_\" .. tostring ( player . UserId )) end if player_profile ~= nil then player_profile : AddUserId ( player . UserId ) player_profile : Reconcile () player_profile : ListenToRelease ( function () PlayerDataService . Profiles [ player ] = nil local ProfileReplica = PlayerDataService . ProfileDataReplicas [ player ] if ProfileReplica ~= nil then ProfileReplica : Destroy () PlayerDataService . ProfileDataReplicas [ player ] = nil end player : Kick () end ) if player : IsDescendantOf ( Players ) == true then local ProfileReplica = ReplicaService . NewReplica ({ ClassToken = SETTINGS . ClassToken , Tags = { Player = player }, Data = player_profile . Data , Replication = \"All\" , }) PlayerDataService . Profiles [ player ] = player_profile PlayerDataService . ProfileDataReplicas [ player ] = ProfileReplica local function OnActiveGlobalUpdate ( UpdateId : number , UpdateData : UpdateData ) assert ( t . number ( UpdateId ) and TYPES . UpdateData ( UpdateData )) player_profile . GlobalUpdates : LockActiveUpdate ( UpdateId ) end local function OnLockedGlobalUpdate ( UpdateId : number , UpdateData : UpdateData ) assert ( t . number ( UpdateId ) and TYPES . UpdateData ( UpdateData )) local LockedUpdateHandler = GlobalUpdateHandlers : FindFirstChild ( UpdateData . Id ) if LockedUpdateHandler then Promise . try ( require ( LockedUpdateHandler ), UpdateId , UpdateData ) : andThen ( function ( ClearUpdate : boolean ) if ClearUpdate ~= false then player_profile . GlobalUpdates : ClearLockedUpdate ( UpdateId ) end end ) : catch ( warn ) : await () else warn ( \"[PlayerDataService]: GlobalUpdateHandler not found\" ) end end for _ , ActiveUpdate in pairs ( player_profile . GlobalUpdates : GetActiveUpdates ()) do OnActiveGlobalUpdate ( ActiveUpdate [ 1 ], ActiveUpdate [ 2 ]) end for _ , LockedUpdate in pairs ( player_profile . GlobalUpdates : GetLockedUpdates ()) do task . spawn ( OnLockedGlobalUpdate , LockedUpdate [ 1 ], LockedUpdate [ 2 ]) end player_profile . GlobalUpdates : ListenToNewActiveUpdate ( OnActiveGlobalUpdate ) player_profile . GlobalUpdates : ListenToNewLockedUpdate ( OnLockedGlobalUpdate ) else player_profile : Release () end else player : Kick () end end local function OnPlayerLeaving ( player : Player ) local player_profile = PlayerDataService . Profiles [ player ] if player_profile ~= nil then player_profile : Release () end end ----- Public ----- function PlayerDataService : GetProfile ( player : Player | any ) assert ( t . instance ( \"Player\" )( player )) return Promise . new ( function ( resolve , reject ) repeat if not player : IsDescendantOf ( Players ) then reject ( \"Player left the game\" ) end task . wait ( 1 ) until PlayerDataService . Profiles [ player ] ~= nil local player_profile = PlayerDataService . Profiles [ player ] if player_profile ~= nil then if player_profile : IsActive () then resolve ( player_profile ) end else reject ( \"Profile is nil\" ) end reject ( \"Player left the game\" ) end ) end function PlayerDataService : GetData ( player : Player | any ) assert ( t . instance ( \"Player\" )( player )) return Promise . new ( function ( resolve , reject ) repeat if not player : IsDescendantOf ( Players ) then reject ( \"Player left the game\" ) end task . wait ( 1 ) until PlayerDataService . Profiles [ player ] ~= nil local player_profile = PlayerDataService . Profiles [ player ] if player_profile ~= nil then if player_profile : IsActive () then resolve ( player_profile . Data ) end else reject ( \"Profile is nil\" ) end reject ( \"Player left the game\" ) end ) end function PlayerDataService : GetDataReplica ( player : Player | any ) assert ( t . instance ( \"Player\" )( player )) return Promise . new ( function ( resolve , reject ) repeat if not player : IsDescendantOf ( Players ) then reject ( \"Player left the game\" ) end task . wait ( 1 ) until PlayerDataService . ProfileDataReplicas [ player ] ~= nil local player_profile_replica = PlayerDataService . ProfileDataReplicas [ player ] if player_profile_replica ~= nil then if player_profile_replica : IsActive () then resolve ( player_profile_replica ) end else reject ( \"player_profile_replica is nil\" ) end reject ( \"Player left the game\" ) end ) end function PlayerDataService : AddGlobalUpdate ( update_data : UpdateData ) assert ( TYPES . UpdateData ( update_data )) return Promise . new ( function ( resolve , reject ) PlayerDataService . ProfileStore : GlobalUpdateProfileAsync ( \"Player_\" .. tostring ( update_data . ReceiverId ), function ( globalUpdates ) globalUpdates : AddActiveUpdate ( update_data ) end ) resolve () end ) end ----- Initialize & Connections ----- function PlayerDataService : KnitInit () for _ , player in pairs ( Players : GetPlayers ()) do task . spawn ( OnPlayerJoining , player ) end -- Used to connect datastore errors to game analytics endpoints for _ , ErrorHandler : ModuleScript in pairs ( ProfileServiceErrorHandlers : GetChildren ()) do if ErrorHandler : IsA ( \"ModuleScript\" ) then if ProfileService [ ErrorHandler . Name ] then ProfileService [ ErrorHandler . Name ]: Connect ( require ( ErrorHandler )) end end end Players . PlayerAdded : Connect ( OnPlayerJoining ) Players . PlayerRemoving : Connect ( OnPlayerLeaving ) end return PlayerDataService","title":"Basic Usage"},{"location":"Controllers/CommandBarController/","text":"A module to initialize and register a keybind to open Cmdr Cmdr Edit the key bind to suit your preference --!strict --[[ {C.G.T} -[CommandBarController]--------------------------------------- Allows you to easily manage essential tools required to run admin commands(Keybinds, e.t.c) Members: Functions: Members [ClassName]: Methods [ClassName]: --]] SETTINGS = {} ----- Loaded Modules ----- local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Knit = require ( ReplicatedStorage . Packages . knit ) local Cmdr = require ( ReplicatedStorage : WaitForChild ( \"CmdrClient\" )) ----- Module Table ----- local CommandBarController = Knit . CreateController ({ Name = \"CommandBarController\" , Client = {}, }) ----- Private Variables ----- ----- Private functions ----- ----- Public ----- ----- Initialize & Connections ----- function CommandBarController : KnitInit () Cmdr : SetActivationKeys ({ Enum . KeyCode . BackSlash }) end return CommandBarController","title":"CommandBarController"},{"location":"Services/CommandBarService/","text":"A module to manage the registering and running of commands made with Cmdr Setting Up Giving Yourself Permissions To Run Commands Locate the permissions module in ServerScriptService.server.Services.CommandBarService.Hooks Add your UserId to the Owners table Warning All members of Owners are able to run commands regardless of whether or not they have been distinctly given permission in the command description module. I recommend only including yourself or the account that manages the game in this table. Creating Commands Locate the commands folder in ServerScriptService.server.Services.CommandBarService Create a new folder give it the a name of the command you want to create Test Create a module with the same name as the folder that returns a description of the command return { Name = \"test\" , Aliases = {}, Description = \"Test.\" , Group = \"Owners, Admins, Moderators\" , --The string just has to contain everyone that has access to these commands and is checked by the Hooks.Permissions BeforeRun function Args = { { Type = \"string\" , Name = \"input\" , Description = \"some input\" , }, }, } Next we create the module to actually run when a command is run and give it the same name as the folder but add Server to the end. This is used by CommandBarService to identify the module to handle the running of the command return function ( context , fromPlayers , toPlayer ) return \"Ran Test.\" end Permissions Cmdr uses a BeforeRun and AfterRun system called hooks to filter attempts to run a command and serve as a way to bind functions to after events run. To register hooks navigate to the Hooks folder in ServerScriptService.server.Services.CommandBarService Create a module that similar to this to register new hooks --!strict --[[ {C.G.T} -[Permissions]--------------------------------------- A module made to determine if a player has the permissions run a commands . Members: Functions: Members [ClassName]: Methods [ClassName]: --]] local SETTINGS = {} ----- Loaded Modules ----- local Players = game : GetService ( \"Players\" ) ----- Module Table ----- local Permissions ----- Private Variables ----- local Groups = { Owners = { 69420 }, Admins = {}, Moderators = {}, --You can also use functions as a member check \ud83d\udcaf -- AccountIsOverADayOld = function(user_id) -- local player = Players:GetPlayerByUserId(user_id) -- if player then -- if player.AccountAge > 1 then -- return true -- end -- end -- return false -- end, } ----- Private functions ----- ----- Public ----- Permissions = function ( registry ) registry : RegisterHook ( \"BeforeRun\" , function ( context ) if table . find ( Groups . Owners , context . Executor . UserId ) then return end for group_name : string , member_check : { number } | () -> boolean | nil in pairs ( Groups ) do if type ( member_check ) == \"table\" then if string.find ( group_name , context . Group ) then if table . find ( member_check , context . Executor . UserId ) then return end end elseif type ( member_check ) == \"function\" then local success , response = pcall ( member_check , context . Executor . UserId ) if success == true and response == true then return end end end return \"You do not meet the requirements to run this command\" end ) end ----- Initialize & Connections ----- return Permissions This module is included in C.G.T and is responsible for determining who has permissions to run commands You can give yourself permissions to run commands by adding your UserId to the Groups table. local Groups = { Owners = { 69420 }, Admins = {}, Moderators = {}, --You can also use functions as a member check \ud83d\udcaf -- AccountIsOverADayOld = function(user_id) -- local player = Players:GetPlayerByUserId(user_id) -- if player then -- if player.AccountAge > 1 then -- return true -- end -- end -- return false -- end, } Lastly make sure you give yourself other members of your team permission to run the command by including their group in the description module. return { Name = \"test\" , Aliases = {}, Description = \"Test.\" , Group = \"Owners, Admins, Moderators\" , --The string just has to contain everyone that has access to these commands and is checked by the Hooks.Permissions BeforeRun function Args = { { Type = \"string\" , Name = \"input\" , Description = \"some input\" , }, }, } Members of Groups can either be a table or a function the purpose of having functions is to allow you to add additional logic, examples include checking account age, playtime, is a member of the star creator group e.t.c","title":"CommandBarService"},{"location":"Services/CommandBarService/#setting-up","text":"","title":"Setting Up"},{"location":"Services/CommandBarService/#giving-yourself-permissions-to-run-commands","text":"Locate the permissions module in ServerScriptService.server.Services.CommandBarService.Hooks Add your UserId to the Owners table Warning All members of Owners are able to run commands regardless of whether or not they have been distinctly given permission in the command description module. I recommend only including yourself or the account that manages the game in this table.","title":"Giving Yourself Permissions To Run Commands"},{"location":"Services/CommandBarService/#creating-commands","text":"Locate the commands folder in ServerScriptService.server.Services.CommandBarService Create a new folder give it the a name of the command you want to create Test Create a module with the same name as the folder that returns a description of the command return { Name = \"test\" , Aliases = {}, Description = \"Test.\" , Group = \"Owners, Admins, Moderators\" , --The string just has to contain everyone that has access to these commands and is checked by the Hooks.Permissions BeforeRun function Args = { { Type = \"string\" , Name = \"input\" , Description = \"some input\" , }, }, } Next we create the module to actually run when a command is run and give it the same name as the folder but add Server to the end. This is used by CommandBarService to identify the module to handle the running of the command return function ( context , fromPlayers , toPlayer ) return \"Ran Test.\" end","title":"Creating Commands"},{"location":"Services/CommandBarService/#permissions","text":"Cmdr uses a BeforeRun and AfterRun system called hooks to filter attempts to run a command and serve as a way to bind functions to after events run. To register hooks navigate to the Hooks folder in ServerScriptService.server.Services.CommandBarService Create a module that similar to this to register new hooks --!strict --[[ {C.G.T} -[Permissions]--------------------------------------- A module made to determine if a player has the permissions run a commands . Members: Functions: Members [ClassName]: Methods [ClassName]: --]] local SETTINGS = {} ----- Loaded Modules ----- local Players = game : GetService ( \"Players\" ) ----- Module Table ----- local Permissions ----- Private Variables ----- local Groups = { Owners = { 69420 }, Admins = {}, Moderators = {}, --You can also use functions as a member check \ud83d\udcaf -- AccountIsOverADayOld = function(user_id) -- local player = Players:GetPlayerByUserId(user_id) -- if player then -- if player.AccountAge > 1 then -- return true -- end -- end -- return false -- end, } ----- Private functions ----- ----- Public ----- Permissions = function ( registry ) registry : RegisterHook ( \"BeforeRun\" , function ( context ) if table . find ( Groups . Owners , context . Executor . UserId ) then return end for group_name : string , member_check : { number } | () -> boolean | nil in pairs ( Groups ) do if type ( member_check ) == \"table\" then if string.find ( group_name , context . Group ) then if table . find ( member_check , context . Executor . UserId ) then return end end elseif type ( member_check ) == \"function\" then local success , response = pcall ( member_check , context . Executor . UserId ) if success == true and response == true then return end end end return \"You do not meet the requirements to run this command\" end ) end ----- Initialize & Connections ----- return Permissions This module is included in C.G.T and is responsible for determining who has permissions to run commands You can give yourself permissions to run commands by adding your UserId to the Groups table. local Groups = { Owners = { 69420 }, Admins = {}, Moderators = {}, --You can also use functions as a member check \ud83d\udcaf -- AccountIsOverADayOld = function(user_id) -- local player = Players:GetPlayerByUserId(user_id) -- if player then -- if player.AccountAge > 1 then -- return true -- end -- end -- return false -- end, } Lastly make sure you give yourself other members of your team permission to run the command by including their group in the description module. return { Name = \"test\" , Aliases = {}, Description = \"Test.\" , Group = \"Owners, Admins, Moderators\" , --The string just has to contain everyone that has access to these commands and is checked by the Hooks.Permissions BeforeRun function Args = { { Type = \"string\" , Name = \"input\" , Description = \"some input\" , }, }, } Members of Groups can either be a table or a function the purpose of having functions is to allow you to add additional logic, examples include checking account age, playtime, is a member of the star creator group e.t.c","title":"Permissions"},{"location":"Services/PlayerDataService/","text":"A module to manage the loading and unloading of player data. Built With ProfileService Setting Up To get started you must first edit SETTINGS.SaveStructure in PlayerDataService . Add and remove variables of SaveStructure as you see fit your needs. Ran into an issue?, Troubleshooting SETTINGS . SaveStructure = { Coins = 10 , Streak = 1 , Rank = \"Owner\" , } It's VERY VERY important that you understand ProfileService . Read the documentation and follow the creator on Twitter \ud83d\ude0e Testing For testing using live profiles in a non destructive manner set SETTINGS.MockProfiles in SETTINGS.MockProfiles to true. Warning GlobalUpdates do not run while profiles are being mocked. You should structure your game in a way that your testing place is separate from your main game to allow you to test without limitations. Basic Usage Changing Data Handling data changes --!strict --[[ {C.G.T} -[TestService]--------------------------------------- A module for testing other modules Members: Functions: Members [ClassName]: Methods [ClassName]: --]] local SETTINGS = {} ----- Loaded Modules ----- local Players = game : GetService ( \"Players\" ) local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Knit = require ( ReplicatedStorage . Packages . knit ) ----- Module Table ----- local TestService = Knit . CreateService ({ Name = \"TemplateService\" }) ----- Private Variables ----- ----- Private functions ----- ----- Public ----- ----- Initialize & Connections ----- function TestService : KnitStart () local player_data_service = Knit . GetService ( \"PlayerDataService\" ) local player = Players : GetPlayers ()[ 1 ] or Players . PlayerAdded : Wait () player_data_service : GetDataReplica ( player ): andThen ( function ( DataReplica ) DataReplica : SetValue ( \"SomeData\" , DataReplica . Data . SomeData + 100 ) -- The value you're changing has to have been added in your save structure end ) end return TestService --!strict --[[ {C.G.T} -[TestController]--------------------------------------- A module for testing other modules Members: Functions: Members [ClassName]: Methods [ClassName]: --]] local SETTINGS = {} ----- Loaded Modules ----- local Players = game : GetService ( \"Players\" ) local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Knit = require ( ReplicatedStorage . Packages . knit ) local ReplicaController = require ( game . ReplicatedStorage . Packages . replicaservice ) ----- Module Table ----- local TestController = Knit . CreateController ({ Name = \"TestController\" }) ----- Private Variables ----- ----- Private functions ----- ----- Public ----- ----- Initialize & Connections ----- function TestController : KnitStart () ReplicaController . ReplicaOfClassCreated ( \"PlayerData\" , function ( replica ) if replica . Tags . Player == Players . LocalPlayer then replica : ListenToChange ( \"SomeData\" , function () print ( \"SomeData Changed\" ) --Do Something when SomeData changes end ) end end ) end return TestController Members ProfileStore Profiles ProfileDataReplicas Functions PlayerDataService:GetData(player): Promise<Profile.Data> PlayerDataService : GetData ( player ): andThen ( function ( data ) print ( data . SomeData ) end ) PlayerDataService:GetProfile(player): Promise<Profile> PlayerDataService : GetProfile ( player ): andThen ( function ( profile ) print ( profile . Data . SomeData ) end ) PlayerDataService:GetDataReplica(player): Promise<ProfileReplica> PlayerDataService : GetDataReplica ( player ): andThen ( function ( profile_replica ) profile_replica : SetValue ( \"SomeData\" , ProfileReplica . Data . SomeData + 100 ) end ) PlayerDataService:AddGlobalUpdate(UpdateData) To set up a GlobalUpdate you should: First make a GlobalUpdateHandler module in the GlobalUpdateHandler Folder(Member of PlayerDataService) and give it a unique name(Name should match type when adding one). Make a an UpdateData Type at the top of the script for intellisense type UpdateData = { Id : string , SenderId : number , TimeSent : number , RecieverId : number , Data : {} } return a function that takes lua UpdateId: number and lua UpdateData: UpdateData as parameter to the function return function ( update_id : number , update_data : UpdateData ) end If false is returned the update won't be cleared and this same function will run on then next time they rejoin. return function ( update_id : number , update_data : UpdateData ) -- Do something with the data like notifying them that they were given something -- How you chose to handle this is completely up to you :D return false end Lastly you just add a GlobalUpdate using the built in AddGlobalUpdate function. PlayerDataService : AddGlobalUpdate ({ Id = \"Gift\" , SenderId = 69420 , TimeSent = os.time (), ReceiverId = 69420 , Data = { SomeData = 10 } })","title":"PlayerDataService"},{"location":"Services/PlayerDataService/#setting-up","text":"To get started you must first edit SETTINGS.SaveStructure in PlayerDataService . Add and remove variables of SaveStructure as you see fit your needs. Ran into an issue?, Troubleshooting SETTINGS . SaveStructure = { Coins = 10 , Streak = 1 , Rank = \"Owner\" , } It's VERY VERY important that you understand ProfileService . Read the documentation and follow the creator on Twitter \ud83d\ude0e","title":"Setting Up"},{"location":"Services/PlayerDataService/#testing","text":"For testing using live profiles in a non destructive manner set SETTINGS.MockProfiles in SETTINGS.MockProfiles to true. Warning GlobalUpdates do not run while profiles are being mocked. You should structure your game in a way that your testing place is separate from your main game to allow you to test without limitations.","title":"Testing"},{"location":"Services/PlayerDataService/#basic-usage","text":"Changing Data Handling data changes --!strict --[[ {C.G.T} -[TestService]--------------------------------------- A module for testing other modules Members: Functions: Members [ClassName]: Methods [ClassName]: --]] local SETTINGS = {} ----- Loaded Modules ----- local Players = game : GetService ( \"Players\" ) local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Knit = require ( ReplicatedStorage . Packages . knit ) ----- Module Table ----- local TestService = Knit . CreateService ({ Name = \"TemplateService\" }) ----- Private Variables ----- ----- Private functions ----- ----- Public ----- ----- Initialize & Connections ----- function TestService : KnitStart () local player_data_service = Knit . GetService ( \"PlayerDataService\" ) local player = Players : GetPlayers ()[ 1 ] or Players . PlayerAdded : Wait () player_data_service : GetDataReplica ( player ): andThen ( function ( DataReplica ) DataReplica : SetValue ( \"SomeData\" , DataReplica . Data . SomeData + 100 ) -- The value you're changing has to have been added in your save structure end ) end return TestService --!strict --[[ {C.G.T} -[TestController]--------------------------------------- A module for testing other modules Members: Functions: Members [ClassName]: Methods [ClassName]: --]] local SETTINGS = {} ----- Loaded Modules ----- local Players = game : GetService ( \"Players\" ) local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Knit = require ( ReplicatedStorage . Packages . knit ) local ReplicaController = require ( game . ReplicatedStorage . Packages . replicaservice ) ----- Module Table ----- local TestController = Knit . CreateController ({ Name = \"TestController\" }) ----- Private Variables ----- ----- Private functions ----- ----- Public ----- ----- Initialize & Connections ----- function TestController : KnitStart () ReplicaController . ReplicaOfClassCreated ( \"PlayerData\" , function ( replica ) if replica . Tags . Player == Players . LocalPlayer then replica : ListenToChange ( \"SomeData\" , function () print ( \"SomeData Changed\" ) --Do Something when SomeData changes end ) end end ) end return TestController","title":"Basic Usage"},{"location":"Services/PlayerDataService/#members","text":"","title":"Members"},{"location":"Services/PlayerDataService/#profilestore","text":"","title":"ProfileStore"},{"location":"Services/PlayerDataService/#profiles","text":"","title":"Profiles"},{"location":"Services/PlayerDataService/#profiledatareplicas","text":"","title":"ProfileDataReplicas"},{"location":"Services/PlayerDataService/#functions","text":"","title":"Functions"},{"location":"Services/PlayerDataService/#playerdataservicegetdataplayer","text":"Promise<Profile.Data> PlayerDataService : GetData ( player ): andThen ( function ( data ) print ( data . SomeData ) end )","title":"PlayerDataService:GetData(player):"},{"location":"Services/PlayerDataService/#playerdataservicegetprofileplayer","text":"Promise<Profile> PlayerDataService : GetProfile ( player ): andThen ( function ( profile ) print ( profile . Data . SomeData ) end )","title":"PlayerDataService:GetProfile(player):"},{"location":"Services/PlayerDataService/#playerdataservicegetdatareplicaplayer","text":"Promise<ProfileReplica> PlayerDataService : GetDataReplica ( player ): andThen ( function ( profile_replica ) profile_replica : SetValue ( \"SomeData\" , ProfileReplica . Data . SomeData + 100 ) end )","title":"PlayerDataService:GetDataReplica(player):"},{"location":"Services/PlayerDataService/#playerdataserviceaddglobalupdateupdatedata","text":"To set up a GlobalUpdate you should: First make a GlobalUpdateHandler module in the GlobalUpdateHandler Folder(Member of PlayerDataService) and give it a unique name(Name should match type when adding one). Make a an UpdateData Type at the top of the script for intellisense type UpdateData = { Id : string , SenderId : number , TimeSent : number , RecieverId : number , Data : {} } return a function that takes lua UpdateId: number and lua UpdateData: UpdateData as parameter to the function return function ( update_id : number , update_data : UpdateData ) end If false is returned the update won't be cleared and this same function will run on then next time they rejoin. return function ( update_id : number , update_data : UpdateData ) -- Do something with the data like notifying them that they were given something -- How you chose to handle this is completely up to you :D return false end Lastly you just add a GlobalUpdate using the built in AddGlobalUpdate function. PlayerDataService : AddGlobalUpdate ({ Id = \"Gift\" , SenderId = 69420 , TimeSent = os.time (), ReceiverId = 69420 , Data = { SomeData = 10 } })","title":"PlayerDataService:AddGlobalUpdate(UpdateData)"},{"location":"Services/PlayerTempDataService/","text":"A module to manage the loading and unloading of player data. Built With ProfileService Setting Up To get started you must first edit SETTINGS.SaveStructure in PlayerTempDataService . Add and remove variables of SaveStructure as you see fit your needs. Ran into an issue?, Troubleshooting SETTINGS . SaveStructure = { SomeRandomTempValue = 10 } Basic Usage Changing TempData Handling TempData Changes --!strict --[[ {C.G.T} -[TestService]--------------------------------------- A module for testing other modules Members: Functions: Members [ClassName]: Methods [ClassName]: --]] local SETTINGS = {} ----- Loaded Modules ----- local Players = game : GetService ( \"Players\" ) local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Knit = require ( ReplicatedStorage . Packages . knit ) ----- Module Table ----- local TestService = Knit . CreateService ({ Name = \"TemplateService\" }) ----- Private Variables ----- ----- Private functions ----- ----- Public ----- ----- Initialize & Connections ----- function TestService : KnitStart () local player_temp_data_service = Knit . GetService ( \"PlayerDataService\" ) local player = Players : GetPlayers ()[ 1 ] or Players . PlayerAdded : Wait () player_temp_data_service : GetDataReplica ( player ): andThen ( function ( DataReplica ) DataReplica : SetValue ( \"SomeData\" , DataReplica . Data . SomeData + 100 ) -- The value you're changing has to have been added in your save structure end ) end return TestService --!strict --[[ {C.G.T} -[TestController]--------------------------------------- A module for testing other modules Members: Functions: Members [ClassName]: Methods [ClassName]: --]] local SETTINGS = {} ----- Loaded Modules ----- local Players = game : GetService ( \"Players\" ) local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Knit = require ( ReplicatedStorage . Packages . knit ) local ReplicaController = require ( game . ReplicatedStorage . Packages . replicaservice ) ----- Module Table ----- local TestController = Knit . CreateController ({ Name = \"TestController\" }) ----- Private Variables ----- ----- Private functions ----- ----- Public ----- ----- Initialize & Connections ----- function TestController : KnitStart () ReplicaController . ReplicaOfClassCreated ( \"PlayerTempData\" , function ( replica ) if replica . Tags . Player == Players . LocalPlayer then replica : ListenToChange ( \"SomeData\" , function () print ( \"SomeData Changed\" ) --Do Something when SomeData changes end ) end end ) end return TestController Members Datas (Yes I am aware that data is a plural) DataReplicas Functions PlayerTempDataService:GetData(player): Promise<TempData> PlayerDataService : GetData ( player ): andThen ( function ( data ) print ( data . SomeTempData ) end ) PlayerDataService:GetDataReplica(player): Promise<TempDataReplica> PlayerDataService : GetDataReplica ( player ): andThen ( function ( profile_replica ) profile_replica : SetValue ( \"SomeTempData\" , ProfileReplica . Data . SomeTempData + 100 ) end )","title":"PlayerTempDataService"},{"location":"Services/PlayerTempDataService/#setting-up","text":"To get started you must first edit SETTINGS.SaveStructure in PlayerTempDataService . Add and remove variables of SaveStructure as you see fit your needs. Ran into an issue?, Troubleshooting SETTINGS . SaveStructure = { SomeRandomTempValue = 10 }","title":"Setting Up"},{"location":"Services/PlayerTempDataService/#basic-usage","text":"Changing TempData Handling TempData Changes --!strict --[[ {C.G.T} -[TestService]--------------------------------------- A module for testing other modules Members: Functions: Members [ClassName]: Methods [ClassName]: --]] local SETTINGS = {} ----- Loaded Modules ----- local Players = game : GetService ( \"Players\" ) local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Knit = require ( ReplicatedStorage . Packages . knit ) ----- Module Table ----- local TestService = Knit . CreateService ({ Name = \"TemplateService\" }) ----- Private Variables ----- ----- Private functions ----- ----- Public ----- ----- Initialize & Connections ----- function TestService : KnitStart () local player_temp_data_service = Knit . GetService ( \"PlayerDataService\" ) local player = Players : GetPlayers ()[ 1 ] or Players . PlayerAdded : Wait () player_temp_data_service : GetDataReplica ( player ): andThen ( function ( DataReplica ) DataReplica : SetValue ( \"SomeData\" , DataReplica . Data . SomeData + 100 ) -- The value you're changing has to have been added in your save structure end ) end return TestService --!strict --[[ {C.G.T} -[TestController]--------------------------------------- A module for testing other modules Members: Functions: Members [ClassName]: Methods [ClassName]: --]] local SETTINGS = {} ----- Loaded Modules ----- local Players = game : GetService ( \"Players\" ) local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Knit = require ( ReplicatedStorage . Packages . knit ) local ReplicaController = require ( game . ReplicatedStorage . Packages . replicaservice ) ----- Module Table ----- local TestController = Knit . CreateController ({ Name = \"TestController\" }) ----- Private Variables ----- ----- Private functions ----- ----- Public ----- ----- Initialize & Connections ----- function TestController : KnitStart () ReplicaController . ReplicaOfClassCreated ( \"PlayerTempData\" , function ( replica ) if replica . Tags . Player == Players . LocalPlayer then replica : ListenToChange ( \"SomeData\" , function () print ( \"SomeData Changed\" ) --Do Something when SomeData changes end ) end end ) end return TestController","title":"Basic Usage"},{"location":"Services/PlayerTempDataService/#members","text":"","title":"Members"},{"location":"Services/PlayerTempDataService/#datasyes-i-am-aware-that-data-is-a-plural","text":"","title":"Datas(Yes I am aware that data is a plural)"},{"location":"Services/PlayerTempDataService/#datareplicas","text":"","title":"DataReplicas"},{"location":"Services/PlayerTempDataService/#functions","text":"","title":"Functions"},{"location":"Services/PlayerTempDataService/#playertempdataservicegetdataplayer","text":"Promise<TempData> PlayerDataService : GetData ( player ): andThen ( function ( data ) print ( data . SomeTempData ) end )","title":"PlayerTempDataService:GetData(player):"},{"location":"Services/PlayerTempDataService/#playerdataservicegetdatareplicaplayer","text":"Promise<TempDataReplica> PlayerDataService : GetDataReplica ( player ): andThen ( function ( profile_replica ) profile_replica : SetValue ( \"SomeTempData\" , ProfileReplica . Data . SomeTempData + 100 ) end )","title":"PlayerDataService:GetDataReplica(player):"}]}